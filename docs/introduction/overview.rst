################
Before you start
################

| This tutorial offers Java developers all the information needed to build a complete blockchain application on the Horizen Sidechain system.

| Apart from Java competency, this tutorial assumes that the reader has a high-level understanding of how blockchain-based distributed software works.

You should be comfortable with concepts like transactions, UTXO's, blocks, validation, confirmation, consensus, unique chains, chain forks, hash functions, private/public keys and signing, along with the concept of a network of nodes and node communication.

If the above words are new to you, you can start by exploring the Horizen Academy website's material (`link <https://academy.horizen.global/>`_). Also, the original whitepaper by Satoshi Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System" (`link <https://bitcoin.org/bitcoin.pdf>`_), can be a good starting point. Direct experience with an existing blockchain software is also useful. For that, you can install the Horizen "zend" software from (`Github <https://github.com/HorizenOfficial/zen>`_), and explore its RPC command interface and "regtest" mode.

****************
Why a Sidechain?
****************

| The success of Bitcoin, and of many of its successors, has led to increasingly frequent attempts to build applications that do not require a trusted third party to ensure that data is stored and processed securely and correctly. These applications keep the concept of a distributed, append-only ledger in place of the traditional application database. This ledger is stored on, and updated by, the application's nodes, which use a consensus mechanism to reach agreement on the legitimacy of transactions, which they then accept and update the ledger. The success of this approach requires, among other things, that the overall system includes an incentive system to adequately reward the app node operators, so that a high degree of decentralization is maintained. The degree of decentralization is such that any attempt at malicious behaviour carries an overwhelmingly uneconomical cost. Today, the only way to guarantee this from day one is to develop a new application in the environment that provides a well-distributed, established, and robust blockchain supporting a traded coin. That way, the robustness of the blockchain extends to the new app, that can immediately make use of the established infrastructure of miners, nodes, and the coin itself.

| Unfortunately, the above approach bears a scalability challenge. Blockchains have traditionally offered very limited ability to provide high transaction rates  and to accommodate sustained transaction peaks. This severely restricts the number of applications that can be deployed on a blockchain. Additionally, each application needs to be coded in the software run by each node participating in the blockchain validation process, which also has an impact on scalability: the node's software must be updated each time we want to add a new application, and cannot grow indefinitely.

| Several attempts have been made to address these limitations; perhaps the most relevant is the idea of equipping each blockchain node with a virtual machine able to run short programs written in a specific, ad-hoc software language, e.g. Ethereum. This approach partially solves the logic scalability issue, as you don’t need to change the node software each time you want to add a new application, but it brings no solution to the limited transaction throughput. Besides, the virtual machine approach typically limits the length and complexity of the application that can be supported.

| The Horizen ecosystem offers an innovative solution to anyone implementing a blockchain-based distributed and decentralized applications. The environment provides a token that is publicly tradable, and that can be used to reward blockchain actors and support the application's business needs, while solving both of the scalability issues identified above. This approach is detailed in the (`Zendoo whitepaper <https://www.horizen.global/assets/files/Horizen-Sidechain-Zendoo-A_zk-SNARK-Verifiable-Cross-Chain-Transfer-Protocol.pdf>`_). The main Horizen blockchain (mainchain), offers the ability to declare the existence of a sidechain  through a specific transaction, and once the integration with the mainchain is completed, sending and receiving ZENs (the Horizen token) to and from that sidechain. There is no need to change the mainchain software each time a developer wants to implement a new application: each application will run on its own, purpose-built blockchain (a “sidechain”). This set of features, now implemented in testnet, is called “Cross-Chain Transfer Protocol”, and is documented in chapter 4 of this tutorial. The Cross-Chain Transfer Protocol does not impose particular requirements on the sidechain architecture, as long as it conforms to the API requirements of the sidechain side of the ZEN exchange protocol.

| The Horizen Sidechain SDK offers all the basic components to build a sidechain that fully supports communication with the mainchain. This codebase implements not only the Cross-Chain Transfer Protocol, but also includes all the other elements needed to run a blockchain; in particular, it ships with a Proof of Stake consensus protocol that offers yet another scalability advantage, this time related to the electrical power required by traditional Proof of Work consensus protocols: we can scale the application logic AND the number of transactions, both without a large increase in the amount of electrical power needed. The architectural and protocol choices implemented by the SDK are introduced in the Zendoo whitepaper, as the “Latus” construction.

To facilitate the sidechain developer's work, the SDK includes an example of a Sidechain Application, “SimpleApp”, that puts together all the standard components provided by the SDK to run a basic sidechain able to receive ZEN coins from the mainchain, exchange them in the sidechain, and send them back to the mainchain. The SimpleApp does not add any new logic, it only configures and uses available classes and objects. Chapter 8 of this tutorial offers a detailed overview of the example, and it’s a great place to start exploring the code.

The next step in developing a new sidechain application is to implement new data and logic in a sidechain node. The “Lambo Registry” example included in the SDK shows how the basic components can be extended to deliver the needed functionalities. The process is documented in Chapter 9, as a step-by-step guide to build a custom sidechain. When that flow is clear, you’ll be ready to bootstrap and run your fully distributed, decentralized blockchain, supporting your data, logic, and handling ZEN coins!

